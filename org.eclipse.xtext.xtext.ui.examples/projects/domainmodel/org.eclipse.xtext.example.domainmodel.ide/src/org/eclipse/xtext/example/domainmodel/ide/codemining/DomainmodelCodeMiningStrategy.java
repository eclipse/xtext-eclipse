/*
 * generated by Xtext
 */
package org.eclipse.xtext.example.domainmodel.ide.codemining;


import java.util.Iterator;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.codemining.ICodeMining;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.example.domainmodel.domainmodel.Operation;
import org.eclipse.xtext.example.domainmodel.services.DomainmodelGrammarAccess;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ui.codemining.XtextCodeMiningProvider;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.util.IAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations;

import com.google.inject.Inject;

@SuppressWarnings("restriction")
public class DomainmodelCodeMiningStrategy extends XtextCodeMiningProvider {
	@Inject
	private IJvmModelAssociations jvmModelAssociations;
	@Inject
	private IQualifiedNameConverter qnConverter;
	@Inject
	private DomainmodelGrammarAccess grammar;
	
	@Override
	protected void createLineHeaderCodeMinings(IDocument document, XtextResource resource, CancelIndicator indicator, IAcceptor<ICodeMining> acceptor) 
			throws BadLocationException{
		int lineCount = document.getNumberOfLines();
		for (int i = 0; i < lineCount; i++) {
			String line = document.get(document.getLineOffset(i), document.getLineLength(i)).trim();
			if(line.contains("op")) {
				//it is an operation
				continue;
			}
			int endIndex = line.indexOf(":");
			if (endIndex != -1) {
				String attrName = line.substring(0, endIndex);
				String attrType = line.substring(endIndex + 1, line.length());
				String headerText = "attribut \'" + attrName + "\' with type \'" + attrType + "\'";
				acceptor.accept(createNewLineHeaderCodeMining(i, document, headerText));
				if (indicator.isCanceled()) {
					return;
				}
			}
		}
	}
	
	@Override
	protected void createLineContentCodeMinings(IDocument document, XtextResource resource, CancelIndicator indicator, IAcceptor<ICodeMining> acceptor) 
			throws BadLocationException {
		//get all operations to open document
		List<Operation> allOperations = EcoreUtil2.eAllOfType(resource.getContents().get(0), Operation.class);
		//get keyword for ')'
		Keyword rightParenthesisKeyword_4 = grammar.getOperationAccess().getRightParenthesisKeyword_4();
		for (Operation o : allOperations) {
			//inline annotations only for methods with no return type
			if (o.getType() != null) {
				continue;
			}
			//get returntype name from operation
			JvmOperation inferredOp = (JvmOperation) jvmModelAssociations.getPrimaryJvmElement(o);
			String returnTypeName = qnConverter.toQualifiedName(inferredOp.getReturnType().getIdentifier()).getLastSegment();
			//find document offset for inline annotation
			ICompositeNode node = NodeModelUtils.findActualNodeFor(o);
			for (Iterator<INode> it = node.getAsTreeIterable().iterator(); it.hasNext();) {
				INode child = it.next();
				if (rightParenthesisKeyword_4.equals(child.getGrammarElement())) {
					//create line content code mining for inline annotation after grammarElement ')'
					String annotationText = " : " + returnTypeName + " ";
					acceptor.accept(createNewLineContentCodeMining(child.getTotalOffset() + 1, annotationText));
					if(indicator.isCanceled()) {
						return;
					}
				}
			}
		}
	}
}
